import tensorflow as tf
import tensorflow_hub as hub
import tensorflow_text
import numpy as np

def _config():
  checkpoint_path = 'BEST_model_categorization.h5'

  bert_preprocess = hub.KerasLayer("https://tfhub.dev/tensorflow/bert_en_uncased_preprocess/3")
  bert_encoder = hub.KerasLayer("https://tfhub.dev/tensorflow/lambert_en_uncased_L-24_H-1024_A-16/2")


  METRICS = [
        tf.keras.metrics.CategoricalAccuracy('accuracy'),
        tf.keras.metrics.Precision(name='precision'),
        tf.keras.metrics.Recall(name='recall')
  ]
  return checkpoint_path, bert_preprocess, bert_encoder, METRICS

def _create_model(bert_preprocess, bert_encoder, METRICS):
  text_input = tf.keras.layers.Input(shape=(), dtype=tf.string, name='text')
  preprocessed_text = bert_preprocess(text_input)
  outputs = bert_encoder(preprocessed_text)
  # Neural network layers
  l = tf.keras.layers.Dropout(0.1, name="dropout")(outputs['pooled_output'])
  l = tf.keras.layers.Dense(1024, activation='relu', name='inter_layer')(l)
  l = tf.keras.layers.Dense(2048, activation='relu', name='intermediate_layer')(l)
  l = tf.keras.layers.Dense(4096, activation='relu', name='ultimate_layer')(l)
  l = tf.keras.layers.Dense(4096, activation='relu', name='extra_layer')(l)
  
  l = tf.keras.layers.Dense(3, activation='softmax', name="output")(l)

  # Use inputs and outputs to construct a final model
  model = tf.keras.Model(inputs=[text_input], outputs = [l])
  model.compile(optimizer='adam',
              loss=tf.keras.losses.CategoricalCrossentropy(),
              metrics=METRICS)

  return model


def _build(verbose):
  checkpoint_path, bert_preprocess, bert_encoder, METRICS = _config()
  basic_model = _create_model(bert_preprocess, bert_encoder, METRICS)
  basic_model.load_weights(checkpoint_path)
  if verbose is True:
    print(basic_model.summary())
  return basic_model

def predict(sequence):
  model = _build(verbose=True)
  out = model.predict(sequence)
  print(out.flatten())
  prediction = np.argmax(out, axis=1)
  #prediction = tf.argmax(out, axis=1)
  return prediction[0]

def _set_category(prediction):
    if prediction == 2:
      malware = 'SMS-Trojan'
    if prediction == 1:
      malware = 'Rootkit'
    if prediction == 0:
      malware = 'Spyware'
    return malware

def categorize(sequence):
  prediction = predict([sequence])
  malware = _set_category(prediction)
  return prediction, malware

